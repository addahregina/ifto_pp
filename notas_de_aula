SOLID
SRP PrincÃ­pio da responsabilidade Ãºnica
OCP PrincÃ­pio aberto e fechado
LSP (Liskov)
- substituiÃ§Ã£o de tipos nÃ£o impacta o sistema
- tipo collection nÃ£o possui mÃ©todos remove e add, apenas consulta
ISP - PrincÃ­pio de segregaÃ§Ã£o da interface
DIP - PrincÃ­pio da inversÃ£o de dependÃªncia (inversÃ£o vs injeÃ§Ã£o)


//aula 13/fev
#2 â™ŸComportamental: PadrÃ£o Strategy ðŸŒ’ 09/02 â˜€ï¸ 14/02
Classe concreta Ã© obrigada a utilizar todos os mÃ©todos, a classe abstrata nÃ£o.

IntelliJ -> Project -> Java -> Maven
Implementar mÃ©todos para interface IntelliJ -> Alt Enter (Interface name) -> Implement Interface();

Return to Interface -> Ctrl+Click (Interface name)

Seta contÃ­nua - Implementada dentro da classe, atributo na origem;
seta dupla: na origem tem atributo da classe de destino e vice-versa

seta pontilhada - dependÃªncia nÃ£o possui atributo da classe de destino
notaÃ§Ãµes UML
+ pÃºblico
- privado
# protegido

composiÃ§Ã£o: um objeto dentro de outro objeto

estrategista sÃ³ relaciona-se com uma classe
strategy : associar o strategista + n associaÃ§Ãµes

mÃ©todo de conveniÃªncia - como se fosse um atalho

no construtor pode passar atributos ou nÃ£o
construtor padrÃ£o nÃ£o tem parÃ¢metros, caso seja criado um construtor com parÃ¢mentros, o outro diexa de existir

CTRL ALT N - Refactor -> Inline -> instancia o objeto no local da chamada // Ã© seguro se uilizada em apenas um local

//AULA 20 DE MARÃ‡O
ATIVIDADE 
https://github.com/manoelcampos/padroes-projetos/tree/master/comportamentais/template-method
TOPICO 6
